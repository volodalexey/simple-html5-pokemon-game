{"version":3,"file":"main.bundle.js","mappings":";;;;;;;;;;;AAAA;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AEhDA;AACA;AACA;AACA;AACA","sources":["webpack://simple-html5-pokemon-game/./src/styles.css","webpack://simple-html5-pokemon-game/./src/BattleScreen.ts","webpack://simple-html5-pokemon-game/./src/Boundary.ts","webpack://simple-html5-pokemon-game/./src/CharacterBox.ts","webpack://simple-html5-pokemon-game/./src/GameLoader.ts","webpack://simple-html5-pokemon-game/./src/MapScreen.ts","webpack://simple-html5-pokemon-game/./src/MoveInterface.ts","webpack://simple-html5-pokemon-game/./src/Player.ts","webpack://simple-html5-pokemon-game/./src/SplashScreen.ts","webpack://simple-html5-pokemon-game/./src/World.ts","webpack://simple-html5-pokemon-game/./src/app.ts","webpack://simple-html5-pokemon-game/./src/logger.ts","webpack://simple-html5-pokemon-game/./src/utils.ts","webpack://simple-html5-pokemon-game/webpack/bootstrap","webpack://simple-html5-pokemon-game/webpack/runtime/chunk loaded","webpack://simple-html5-pokemon-game/webpack/runtime/define property getters","webpack://simple-html5-pokemon-game/webpack/runtime/global","webpack://simple-html5-pokemon-game/webpack/runtime/hasOwnProperty shorthand","webpack://simple-html5-pokemon-game/webpack/runtime/make namespace object","webpack://simple-html5-pokemon-game/webpack/runtime/node module decorator","webpack://simple-html5-pokemon-game/webpack/runtime/jsonp chunk loading","webpack://simple-html5-pokemon-game/webpack/before-startup","webpack://simple-html5-pokemon-game/webpack/startup","webpack://simple-html5-pokemon-game/webpack/after-startup"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport {};","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BattleScreen = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nconst CharacterBox_1 = require(\"./CharacterBox\");\nconst logger_1 = require(\"./logger\");\nclass BattleScreen extends pixi_js_1.Container {\n    constructor(options) {\n        super();\n        this.isActive = false;\n        this.animationSpeed = 0.05;\n        this.setup(options);\n    }\n    setup(options) {\n        this.setupBackground(options);\n        this.setupVersus(options);\n        this.setupCharacterBoxes(options);\n    }\n    setupBackground({ sprites: { background } }) {\n        const bgSpr = new pixi_js_1.Sprite(background);\n        this.addChild(bgSpr);\n        this.background = bgSpr;\n    }\n    setupVersus({ sprites: { draggle, emby } }) {\n        const drlSpr = new pixi_js_1.AnimatedSprite(draggle);\n        drlSpr.animationSpeed = this.animationSpeed;\n        this.addChild(drlSpr);\n        this.draggle = drlSpr;\n        this.draggle.x = 800;\n        this.draggle.y = 95;\n        const embSpr = new pixi_js_1.AnimatedSprite(emby);\n        embSpr.animationSpeed = this.animationSpeed;\n        this.addChild(embSpr);\n        this.emby = embSpr;\n        this.emby.x = 300;\n        this.emby.y = 330;\n    }\n    activate() {\n        this.isActive = true;\n        this.draggle.play();\n        this.emby.play();\n    }\n    deactivate() {\n        this.isActive = false;\n        this.draggle.stop();\n        this.emby.stop();\n    }\n    handleScreenTick() { }\n    handleScreenResize({ viewWidth, viewHeight }) {\n        const availableWidth = viewWidth;\n        const availableHeight = viewHeight;\n        const totalWidth = this.background.width;\n        const totalHeight = this.background.height;\n        let scale = 1;\n        if (totalHeight >= totalWidth) {\n            scale = availableHeight / totalHeight;\n            if (scale * totalWidth > availableWidth) {\n                scale = availableWidth / totalWidth;\n            }\n            (0, logger_1.logBattleLayout)(`By height (sc=${scale})`);\n        }\n        else {\n            scale = availableWidth / totalWidth;\n            (0, logger_1.logBattleLayout)(`By width (sc=${scale})`);\n            if (scale * totalHeight > availableHeight) {\n                scale = availableHeight / totalHeight;\n            }\n        }\n        const occupiedWidth = Math.floor(totalWidth * scale);\n        const occupiedHeight = Math.floor(totalHeight * scale);\n        const x = availableWidth > occupiedWidth ? (availableWidth - occupiedWidth) / 2 : 0;\n        const y = availableHeight > occupiedHeight ? (availableHeight - occupiedHeight) / 2 : 0;\n        (0, logger_1.logBattleLayout)(`aw=${availableWidth} (ow=${occupiedWidth}) x=${x} ah=${availableHeight} (oh=${occupiedHeight}) y=${y}`);\n        this.x = x;\n        this.width = occupiedWidth;\n        this.y = y;\n        this.height = occupiedHeight;\n        (0, logger_1.logBattleLayout)(`x=${x} y=${y} w=${this.width} h=${this.height}`);\n    }\n    setupCharacterBoxes(options) {\n        const draggleBox = new CharacterBox_1.CharacterBox({\n            name: 'Draggle'\n        });\n        draggleBox.x = 50;\n        draggleBox.y = 50;\n        this.addChild(draggleBox);\n        this.draggleBox = draggleBox;\n        const embyBox = new CharacterBox_1.CharacterBox({\n            name: 'Emby'\n        });\n        embyBox.x = this.background.width - (embyBox.width + 50);\n        embyBox.y = 330;\n        this.addChild(embyBox);\n        this.embyBox = embyBox;\n    }\n}\nexports.BattleScreen = BattleScreen;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Boundary = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nconst logger_1 = require(\"./logger\");\nclass Boundary extends pixi_js_1.Graphics {\n    constructor({ rect, fillColor = 0xff0000 }) {\n        super();\n        this._rect = rect;\n        this.x = rect.x;\n        this.y = rect.y;\n        this.fillColor = fillColor;\n        this.draw();\n        if (logger_1.logBoundary.enabled) {\n            this.visible = true;\n            this.alpha = 0.3;\n        }\n        else {\n            this.visible = false;\n        }\n    }\n    draw() {\n        this.clear();\n        this.beginFill(this.fillColor);\n        this.drawRect(0, 0, this._rect.width, this._rect.height);\n        this.endFill();\n    }\n}\nexports.Boundary = Boundary;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CharacterBox = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nclass CharacterBox extends pixi_js_1.Container {\n    constructor(options) {\n        super();\n        this.boxWidth = 250;\n        this.boxHeight = 60;\n        this.boxColor = 0xffffff;\n        this.boxBorderThick = 4;\n        this.boxBorderColor = 0x000000;\n        this.name = options.name;\n        this.setup();\n        this.draw();\n    }\n    setup() {\n        this.box = new pixi_js_1.Graphics();\n        this.addChild(this.box);\n        this.lifeBar = new pixi_js_1.Graphics();\n        this.addChild(this.lifeBar);\n        this.text = new pixi_js_1.Text(this.name, {\n            fontFamily: 'Press Start 2P',\n            fontSize: 24,\n            fill: 0xff1010,\n            align: 'center'\n        });\n        this.addChild(this.text);\n    }\n    draw() {\n        const { box, boxBorderColor, boxWidth, boxHeight, boxColor, boxBorderThick } = this;\n        box.clear();\n        box.beginFill(boxBorderColor);\n        box.drawRect(0, 0, boxWidth, boxHeight);\n        box.endFill();\n        box.beginFill(boxColor);\n        box.drawRect(0 + boxBorderThick, 0 + boxBorderThick, boxWidth - boxBorderThick * 2, boxHeight - boxBorderThick * 2);\n        box.endFill();\n    }\n}\nexports.CharacterBox = CharacterBox;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GameLoader = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nclass GameLoader {\n    constructor() {\n        this.loader = pixi_js_1.Assets;\n    }\n    async loadAll() {\n        await this.loadSettings();\n        await this.loadResources();\n        await this.loadImages();\n    }\n    async loadSettings() {\n        this.settings = await fetch('settings.json').then(async (res) => await res.json());\n    }\n    async loadResources() {\n        this.loader.add('tileset', 'assets/spritesheets/spritesheet.json');\n        this.spritesheet = await this.loader.load('tileset');\n    }\n    async loadImage(url) {\n        const res = await fetch(url);\n        const imageBlob = await res.blob();\n        const blobURL = URL.createObjectURL(imageBlob);\n        return await pixi_js_1.Texture.fromURL(blobURL);\n    }\n    async loadImages() {\n        const [worldBgTexture, worldFgTexture, battleBgTexture] = await Promise.all([\n            this.loadImage('assets/images/World-Background.png'),\n            this.loadImage('assets/images/World-Foreground.png'),\n            this.loadImage('assets/images/Battle-Background.png')\n        ]);\n        this.worldBackgroundTexture = worldBgTexture;\n        this.worldForegroundTexture = worldFgTexture;\n        this.battleBackgroundTexture = battleBgTexture;\n    }\n}\nexports.GameLoader = GameLoader;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapScreen = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nconst Boundary_1 = require(\"./Boundary\");\nconst logger_1 = require(\"./logger\");\nconst MoveInterface_1 = require(\"./MoveInterface\");\nconst Player_1 = require(\"./Player\");\nconst utils_1 = require(\"./utils\");\nclass MapScreen extends pixi_js_1.Container {\n    constructor(options) {\n        super();\n        this.cellWidth = 48;\n        this.cellHeight = 48;\n        this.isActive = false;\n        this.tilesPerRow = 70;\n        this.boundaries = [];\n        this.battleZones = [];\n        this.overlappingBattleTrigger = 0.5;\n        this.overlappingBattleChance = 0.01;\n        this.handleKeydown = (e) => {\n            const { player } = this;\n            (0, logger_1.logKeydown)(e.key);\n            switch (e.key) {\n                case 'w':\n                case 'ArrowUp':\n                    player.addUpImpulse();\n                    break;\n                case 'a':\n                case 'ArrowLeft':\n                    player.addLeftImpulse();\n                    break;\n                case 's':\n                case 'ArrowDown':\n                    player.addDownImpulse();\n                    break;\n                case 'd':\n                case 'ArrowRight':\n                    player.addRightImpulse();\n                    break;\n            }\n        };\n        this.handleKeyup = (e) => {\n            const { player } = this;\n            (0, logger_1.logKeyup)(e.key);\n            switch (e.key) {\n                case 'w':\n                case 'ArrowUp':\n                    player.subUpImpulse();\n                    break;\n                case 'a':\n                case 'ArrowLeft':\n                    player.subLeftImpulse();\n                    break;\n                case 's':\n                case 'ArrowDown':\n                    player.subDownImpulse();\n                    break;\n                case 'd':\n                case 'ArrowRight':\n                    player.subRightImpulse();\n                    break;\n            }\n        };\n        this.handleDirectionPressedChange = () => {\n            const { up, right, down, left } = this.moveInterface.directionPressed;\n            this.player.setImpulse({\n                up,\n                right,\n                down,\n                left\n            });\n        };\n        this.onBattleStart = options.onBattleStart;\n        this.setup(options);\n    }\n    setup(options) {\n        this.setupBackground(options);\n        this.setupLayers(options);\n        this.setupPlayer(options);\n        this.setupForeground(options);\n        this.setupMoveInterface(options);\n    }\n    setupLayers({ collisionsLayer, battleZonesLayer }) {\n        const { tilesPerRow } = this;\n        for (let i = 0; i < collisionsLayer.data.length; i += tilesPerRow) {\n            const row = collisionsLayer.data.slice(i, tilesPerRow + i);\n            row.forEach((symbol, j) => {\n                if (symbol === 1025) {\n                    const boundary = new Boundary_1.Boundary({\n                        rect: {\n                            x: j * this.cellWidth,\n                            y: i / tilesPerRow * this.cellHeight,\n                            width: this.cellWidth,\n                            height: this.cellHeight\n                        }\n                    });\n                    this.boundaries.push(boundary);\n                    this.addChild(boundary);\n                }\n            });\n        }\n        for (let i = 0; i < battleZonesLayer.data.length; i += tilesPerRow) {\n            const row = battleZonesLayer.data.slice(i, tilesPerRow + i);\n            row.forEach((symbol, j) => {\n                if (symbol === 1025) {\n                    const boundary = new Boundary_1.Boundary({\n                        rect: {\n                            x: j * this.cellWidth,\n                            y: i / tilesPerRow * this.cellHeight,\n                            width: this.cellWidth,\n                            height: this.cellHeight\n                        },\n                        fillColor: 0x0000ff\n                    });\n                    this.battleZones.push(boundary);\n                    this.addChild(boundary);\n                }\n            });\n        }\n    }\n    setupBackground({ mapSprites: { background } }) {\n        const bgSpr = new pixi_js_1.Sprite(background);\n        this.addChild(bgSpr);\n        this.background = bgSpr;\n    }\n    setupPlayer({ playerSprites: { up, left, right, down } }) {\n        this.player = new Player_1.Player({\n            position: {\n                x: 1225,\n                y: 880\n            },\n            sprites: {\n                up,\n                left,\n                right,\n                down\n            }\n        });\n        this.addChild(this.player);\n    }\n    setupForeground({ mapSprites: { foreground } }) {\n        const fgSpr = new pixi_js_1.Sprite(foreground);\n        this.addChild(fgSpr);\n        this.foreground = fgSpr;\n    }\n    activate() {\n        this.isActive = true;\n        this.addEventLesteners();\n    }\n    deactivate() {\n        this.isActive = false;\n        this.removeEventLesteners();\n        this.player.releaseAllImpulse();\n    }\n    handleScreenTick() {\n        if (!this.isActive) {\n            return;\n        }\n        let isMovingHorizontal = false;\n        const horizontalPlayerImpulse = this.player.getHorizontalImpulse();\n        if (horizontalPlayerImpulse !== 0) {\n            isMovingHorizontal = true;\n            const pRectHor = {\n                x: this.player.x + horizontalPlayerImpulse,\n                y: this.player.y,\n                width: this.player.width,\n                height: this.player.height\n            };\n            for (let i = 0; i < this.boundaries.length; i++) {\n                const boundary = this.boundaries[i];\n                if ((0, utils_1.rectangularCollision)({\n                    rect1: pRectHor,\n                    rect2: boundary\n                })) {\n                    (0, logger_1.logPlayerCollision)('Horizontal collision detected! Player stopped');\n                    isMovingHorizontal = false;\n                    break;\n                }\n            }\n        }\n        let isMovingVertical = false;\n        const verticalPlayerImpulse = this.player.getVerticalImpulse();\n        if (verticalPlayerImpulse !== 0) {\n            isMovingVertical = true;\n            const pRectVer = {\n                x: this.player.x,\n                y: this.player.y + verticalPlayerImpulse,\n                width: this.player.width,\n                height: this.player.height\n            };\n            for (let i = 0; i < this.boundaries.length; i++) {\n                const boundary = this.boundaries[i];\n                if ((0, utils_1.rectangularCollision)({\n                    rect1: pRectVer,\n                    rect2: boundary\n                })) {\n                    (0, logger_1.logPlayerCollision)('Vertical collision detected! Player stopped');\n                    isMovingVertical = false;\n                    break;\n                }\n            }\n        }\n        if (horizontalPlayerImpulse > 0 || verticalPlayerImpulse > 0) {\n            for (let i = 0; i < this.battleZones.length; i++) {\n                const battleZone = this.battleZones[i];\n                const overlappingArea = (Math.min(this.player.x + this.player.width, battleZone.x + battleZone.width) -\n                    Math.max(this.player.x, battleZone.x)) *\n                    (Math.min(this.player.y + this.player.height, battleZone.y + battleZone.height) -\n                        Math.max(this.player.y, battleZone.y));\n                if ((0, utils_1.rectangularCollision)({\n                    rect1: this.player,\n                    rect2: battleZone\n                }) &&\n                    overlappingArea > (this.player.width * this.player.height) * this.overlappingBattleTrigger &&\n                    Math.random() <= this.overlappingBattleChance) {\n                    (0, logger_1.logPlayerCollision)('Battle zone triggered');\n                    this.onBattleStart();\n                }\n            }\n        }\n        if (isMovingHorizontal) {\n            this.player.x += horizontalPlayerImpulse;\n            this.x -= horizontalPlayerImpulse;\n            this.moveInterface.x += horizontalPlayerImpulse;\n        }\n        if (isMovingVertical) {\n            this.player.y += verticalPlayerImpulse;\n            this.y -= verticalPlayerImpulse;\n            this.moveInterface.y += verticalPlayerImpulse;\n        }\n    }\n    addEventLesteners() {\n        window.addEventListener('keydown', this.handleKeydown);\n        window.addEventListener('keyup', this.handleKeyup);\n    }\n    removeEventLesteners() {\n        window.removeEventListener('keydown', this.handleKeydown);\n        window.removeEventListener('keyup', this.handleKeyup);\n    }\n    setupMoveInterface({ viewWidth, viewHeight }) {\n        const moveInterface = new MoveInterface_1.MoveInterface({\n            viewWidth,\n            viewHeight,\n            playerWidth: this.player.width,\n            playerHeight: this.player.height,\n            onDirectionPressedChange: this.handleDirectionPressedChange\n        });\n        this.addChild(moveInterface);\n        this.moveInterface = moveInterface;\n    }\n    resizeMoveInterface({ viewWidth, viewHeight }) {\n        this.moveInterface.x = (this.player.x + this.player.width / 2) - viewWidth / 2;\n        this.moveInterface.y = (this.player.y + this.player.height / 2) - viewHeight / 2;\n        this.moveInterface.width = viewWidth;\n        this.moveInterface.height = viewHeight;\n    }\n    centerCamera({ viewWidth, viewHeight }) {\n        this.x = -(this.player.x + this.player.width / 2) + viewWidth / 2;\n        this.y = -(this.player.y + this.player.height / 2) + viewHeight / 2;\n    }\n    handleScreenResize(options) {\n        this.centerCamera(options);\n        this.resizeMoveInterface(options);\n    }\n}\nexports.MapScreen = MapScreen;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MoveInterface = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nconst logger_1 = require(\"./logger\");\nvar EnumDirection;\n(function (EnumDirection) {\n    EnumDirection[\"up\"] = \"up\";\n    EnumDirection[\"right\"] = \"right\";\n    EnumDirection[\"down\"] = \"down\";\n    EnumDirection[\"left\"] = \"left\";\n})(EnumDirection || (EnumDirection = {}));\nclass MoveInterface extends pixi_js_1.Container {\n    constructor(options) {\n        super();\n        this.isPressed = false;\n        this.maximizePressure = 'allAxes';\n        this.directionPressed = {\n            up: 0,\n            right: 0,\n            down: 0,\n            left: 0\n        };\n        this.interactive = true;\n        this.playerWidth = options.playerWidth;\n        this.playerHeight = options.playerHeight;\n        this.onDirectionPressedChange = options.onDirectionPressedChange;\n        this.setup();\n        this.draw(options);\n    }\n    setup() {\n        const polygon = new pixi_js_1.Graphics();\n        polygon.alpha = logger_1.logMoveInterface.enabled ? 0.5 : 0;\n        this.addChild(polygon);\n        this.polygon = polygon;\n        this.setupEventLesteners();\n    }\n    draw({ viewWidth, viewHeight, upFillColor = 0xff0000, upRightFillColor = 0xffff00, rightFillColor = 0x0000ff, downRightFillColor = 0xffffff, downFillColor = 0x00ff00, downLeftFillColor = 0x00ffff, leftFillColor = 0xff00ff, upLeftFillColor = 0x000000 }) {\n        const halfWidth = viewWidth / 2;\n        const halfLeft = halfWidth - this.playerWidth / 2;\n        const halfRight = halfWidth + this.playerWidth / 2;\n        const halfHeight = viewHeight / 2;\n        const halfTop = halfHeight - this.playerHeight / 2;\n        const halfBottom = halfHeight + this.playerHeight / 2;\n        this.polygon.beginFill(upFillColor);\n        this.polygon.drawPolygon([\n            { x: halfLeft, y: 0 }, { x: halfRight, y: 0 },\n            { x: halfRight, y: halfTop }, { x: halfLeft, y: halfTop }\n        ]);\n        this.polygon.endFill();\n        this.polygon.beginFill(upRightFillColor);\n        this.polygon.drawPolygon([\n            { x: halfRight, y: 0 }, { x: viewWidth, y: 0 },\n            { x: viewWidth, y: halfTop }, { x: halfRight, y: halfTop }\n        ]);\n        this.polygon.endFill();\n        this.polygon.beginFill(rightFillColor);\n        this.polygon.drawPolygon([\n            { x: halfRight, y: halfTop }, { x: viewWidth, y: halfTop },\n            { x: viewWidth, y: halfBottom }, { x: halfRight, y: halfBottom }\n        ]);\n        this.polygon.endFill();\n        this.polygon.beginFill(downRightFillColor);\n        this.polygon.drawPolygon([\n            { x: halfRight, y: halfBottom }, { x: viewWidth, y: halfBottom },\n            { x: viewWidth, y: viewHeight }, { x: halfRight, y: viewHeight }\n        ]);\n        this.polygon.endFill();\n        this.polygon.beginFill(downFillColor);\n        this.polygon.drawPolygon([\n            { x: halfLeft, y: halfBottom }, { x: halfRight, y: halfBottom },\n            { x: halfRight, y: viewHeight }, { x: halfLeft, y: viewHeight }\n        ]);\n        this.polygon.endFill();\n        this.polygon.beginFill(downLeftFillColor);\n        this.polygon.drawPolygon([\n            { x: 0, y: halfBottom }, { x: halfLeft, y: halfBottom },\n            { x: halfLeft, y: viewHeight }, { x: 0, y: viewHeight }\n        ]);\n        this.polygon.endFill();\n        this.polygon.beginFill(leftFillColor);\n        this.polygon.drawPolygon([\n            { x: 0, y: halfTop }, { x: halfLeft, y: halfTop },\n            { x: halfLeft, y: halfBottom }, { x: 0, y: halfBottom }\n        ]);\n        this.polygon.endFill();\n        this.polygon.beginFill(upLeftFillColor);\n        this.polygon.drawPolygon([\n            { x: 0, y: 0 }, { x: halfLeft, y: 0 },\n            { x: halfLeft, y: halfTop }, { x: 0, y: halfTop }\n        ]);\n        this.polygon.endFill();\n    }\n    setupEventLesteners() {\n        this.on('pointerdown', (e) => {\n            this.setDirectionPressed(true, e.clientX, e.clientY);\n        });\n        this.on('pointermove', (e) => {\n            this.setDirectionPressed(undefined, e.clientX, e.clientY);\n        });\n        this.on('pointerup', (e) => {\n            this.setDirectionPressed(false, e.clientX, e.clientY);\n        });\n    }\n    setDirectionPressed(pressed, x, y) {\n        if (typeof pressed === 'boolean') {\n            this.isPressed = pressed;\n        }\n        const { directionPressed } = this;\n        Object.keys(directionPressed).forEach(key => {\n            directionPressed[key] = 0;\n        });\n        if (this.isPressed) {\n            const halfWidth = this.width / 2;\n            const halfHeight = this.height / 2;\n            const halfLeft = halfWidth - this.playerWidth / 2;\n            const maxHorizontal = halfLeft;\n            const halfRight = halfWidth + this.playerWidth / 2;\n            const halfTop = halfHeight - this.playerHeight / 2;\n            const maxVertical = halfTop;\n            const halfBottom = halfHeight + this.playerHeight / 2;\n            const rightPressure = x >= halfRight ? (x - halfRight) / maxHorizontal : 0;\n            const leftPressure = x <= halfLeft ? (halfLeft - x) / maxHorizontal : 0;\n            if (rightPressure > 0) {\n                directionPressed.right = rightPressure;\n            }\n            else if (leftPressure > 0) {\n                directionPressed.left = leftPressure;\n            }\n            const downPressure = y >= halfBottom ? (y - halfBottom) / maxVertical : 0;\n            const upPressure = y <= halfTop ? (halfTop - y) / maxVertical : 0;\n            if (downPressure > 0) {\n                directionPressed.down = downPressure;\n            }\n            else if (upPressure > 0) {\n                directionPressed.up = upPressure;\n            }\n            if (this.maximizePressure !== 'none') {\n                if (this.maximizePressure === 'mainAxis') {\n                    const maxHorizontal = Math.max(directionPressed.left, directionPressed.right);\n                    const maxVertical = Math.max(directionPressed.up, directionPressed.down);\n                    if (maxHorizontal > 0 && maxHorizontal > maxVertical) {\n                        if (directionPressed.left > 0) {\n                            directionPressed.left = 1;\n                        }\n                        else if (directionPressed.right > 0) {\n                            directionPressed.right = 1;\n                        }\n                    }\n                    else if (maxVertical > 0 && maxVertical > maxHorizontal) {\n                        if (directionPressed.up > 0) {\n                            directionPressed.up = 1;\n                        }\n                        else if (directionPressed.down > 0) {\n                            directionPressed.down = 1;\n                        }\n                    }\n                    else if (maxHorizontal > 0 && maxHorizontal === maxVertical) {\n                        if (directionPressed.left > 0) {\n                            directionPressed.left = 1;\n                        }\n                        else if (directionPressed.right > 0) {\n                            directionPressed.right = 1;\n                        }\n                        if (directionPressed.up > 0) {\n                            directionPressed.up = 1;\n                        }\n                        else if (directionPressed.down > 0) {\n                            directionPressed.down = 1;\n                        }\n                    }\n                }\n                else {\n                    if (directionPressed.left > 0) {\n                        directionPressed.left = 1;\n                    }\n                    else if (directionPressed.right > 0) {\n                        directionPressed.right = 1;\n                    }\n                    if (directionPressed.up > 0) {\n                        directionPressed.up = 1;\n                    }\n                    else if (directionPressed.down > 0) {\n                        directionPressed.down = 1;\n                    }\n                }\n            }\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            (0, logger_1.logPointerEvent)(`pressed=${pressed} x=${x} y=${y} hw=${halfWidth} hh=${halfHeight}`);\n        }\n        this.onDirectionPressedChange();\n    }\n}\nexports.MoveInterface = MoveInterface;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Player = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nconst logger_1 = require(\"./logger\");\nvar PlayerDirection;\n(function (PlayerDirection) {\n    PlayerDirection[PlayerDirection[\"up\"] = 0] = \"up\";\n    PlayerDirection[PlayerDirection[\"down\"] = 1] = \"down\";\n    PlayerDirection[PlayerDirection[\"left\"] = 2] = \"left\";\n    PlayerDirection[PlayerDirection[\"right\"] = 3] = \"right\";\n})(PlayerDirection || (PlayerDirection = {}));\nclass Player extends pixi_js_1.Container {\n    constructor(options) {\n        super();\n        this.DIRECTIONS = PlayerDirection;\n        this.animationSpeed = 0.1;\n        this.velocity = 3;\n        this.impulse = {\n            up: 0,\n            left: 0,\n            right: 0,\n            down: 0\n        };\n        this.setup(options);\n        this.setDirection(PlayerDirection.down);\n        this.x = options.position.x;\n        this.y = options.position.y;\n    }\n    hideAllDirections() {\n        [this.up, this.left, this.right, this.down].forEach(spr => {\n            spr.visible = false;\n        });\n    }\n    setDirection(dir) {\n        this.hideAllDirections();\n        switch (dir) {\n            case PlayerDirection.down:\n                this.down.visible = true;\n                break;\n            case PlayerDirection.left:\n                this.left.visible = true;\n                break;\n            case PlayerDirection.right:\n                this.right.visible = true;\n                break;\n            case PlayerDirection.up:\n                this.up.visible = true;\n                break;\n        }\n        this._direction = dir;\n    }\n    stopAllAnimations() {\n        [this.up, this.left, this.right, this.down].forEach(spr => {\n            spr.stop();\n        });\n    }\n    playAnimation() {\n        this.stopAllAnimations();\n        switch (this._direction) {\n            case PlayerDirection.down:\n                this.down.play();\n                break;\n            case PlayerDirection.left:\n                this.left.play();\n                break;\n            case PlayerDirection.right:\n                this.right.play();\n                break;\n            case PlayerDirection.up:\n                this.up.play();\n                break;\n        }\n    }\n    setup({ sprites: { up, left, right, down } }) {\n        const upSpr = new pixi_js_1.AnimatedSprite(up);\n        upSpr.animationSpeed = this.animationSpeed;\n        this.addChild(upSpr);\n        this.up = upSpr;\n        const leftSpr = new pixi_js_1.AnimatedSprite(left);\n        leftSpr.animationSpeed = this.animationSpeed;\n        this.addChild(leftSpr);\n        this.left = leftSpr;\n        const righSpr = new pixi_js_1.AnimatedSprite(right);\n        righSpr.animationSpeed = this.animationSpeed;\n        this.addChild(righSpr);\n        this.right = righSpr;\n        const downSpr = new pixi_js_1.AnimatedSprite(down);\n        downSpr.animationSpeed = this.animationSpeed;\n        this.addChild(downSpr);\n        this.down = downSpr;\n    }\n    setImpulse(impulse) {\n        /* eslint-disable @typescript-eslint/restrict-template-expressions */\n        (0, logger_1.logPlayerImpulse)(`Got impulse up=${impulse.up} left=${impulse.left} right=${impulse.right} down=${impulse.down}`);\n        Object.assign(this.impulse, impulse);\n        if (typeof impulse.up === 'number' && impulse.up > 0 && this.impulse.down > 0) {\n            this.impulse.down = 0;\n        }\n        else if (typeof impulse.left === 'number' && impulse.left > 0 && this.impulse.right > 0) {\n            this.impulse.right = 0;\n        }\n        else if (typeof impulse.right === 'number' && impulse.right > 0 && this.impulse.left > 0) {\n            this.impulse.left = 0;\n        }\n        else if (typeof impulse.down === 'number' && impulse.down > 0 && this.impulse.up > 0) {\n            this.impulse.up = 0;\n        }\n        if (this.impulse.left > 0) {\n            this.setDirection(PlayerDirection.left);\n        }\n        else if (this.impulse.right > 0) {\n            this.setDirection(PlayerDirection.right);\n        }\n        else if (this.impulse.up > 0) {\n            this.setDirection(PlayerDirection.up);\n        }\n        else if (this.impulse.down > 0) {\n            this.setDirection(PlayerDirection.down);\n        }\n        if (this.impulse.left > 0 || this.impulse.right > 0 || this.impulse.up > 0 || this.impulse.down > 0) {\n            this.playAnimation();\n        }\n        else {\n            this.stopAllAnimations();\n        }\n        (0, logger_1.logPlayerImpulse)(`up=${this.impulse.up} left=${this.impulse.left} right=${this.impulse.right} down=${this.impulse.down}`);\n        /* eslint-enable @typescript-eslint/restrict-template-expressions */\n    }\n    addUpImpulse() {\n        this.setImpulse({ up: 1 });\n    }\n    subUpImpulse() {\n        this.setImpulse({ up: 0 });\n    }\n    addLeftImpulse() {\n        this.setImpulse({ left: 1 });\n    }\n    subLeftImpulse() {\n        this.setImpulse({ left: 0 });\n    }\n    addRightImpulse() {\n        this.setImpulse({ right: 1 });\n    }\n    subRightImpulse() {\n        this.setImpulse({ right: 0 });\n    }\n    addDownImpulse() {\n        this.setImpulse({ down: 1 });\n    }\n    subDownImpulse() {\n        this.setImpulse({ down: 0 });\n    }\n    releaseAllImpulse() {\n        this.setImpulse({ up: 0, left: 0, right: 0, down: 0 });\n    }\n    getVerticalImpulse() {\n        return this.impulse.up > 0 ? -this.velocity * this.impulse.up : this.impulse.down > 0 ? this.velocity * this.impulse.down : 0;\n    }\n    getHorizontalImpulse() {\n        return this.impulse.left > 0 ? -this.velocity * this.impulse.left : this.impulse.right > 0 ? this.velocity * this.impulse.right : 0;\n    }\n}\nexports.Player = Player;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SplashScreen = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nclass SplashScreen extends pixi_js_1.Container {\n    constructor(options) {\n        super();\n        this.isActive = false;\n        this.fillColor = 0x000000;\n        this.setup();\n        this.draw(options);\n        this.alpha = 0;\n    }\n    setup() {\n        this.graphics = new pixi_js_1.Graphics();\n        this.addChild(this.graphics);\n    }\n    draw({ viewWidth, viewHeight }) {\n        this.graphics.beginFill(this.fillColor);\n        this.graphics.drawRect(0, 0, viewWidth, viewHeight);\n        this.graphics.endFill();\n    }\n    activate() {\n        this.isActive = true;\n    }\n    deactivate() {\n        this.isActive = false;\n    }\n    handleScreenTick() { }\n    resizeGraphics({ viewWidth, viewHeight }) {\n        this.width = viewWidth;\n        this.height = viewHeight;\n    }\n    handleScreenResize(options) {\n        this.resizeGraphics(options);\n    }\n}\nexports.SplashScreen = SplashScreen;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.World = void 0;\nconst gsap_1 = __importDefault(require(\"gsap\"));\nconst MapScreen_1 = require(\"./MapScreen\");\nconst BattleScreen_1 = require(\"./BattleScreen\");\nconst SplashScreen_1 = require(\"./SplashScreen\");\nconst logger_1 = require(\"./logger\");\nvar WorldScreen;\n(function (WorldScreen) {\n    WorldScreen[WorldScreen[\"map\"] = 0] = \"map\";\n    WorldScreen[WorldScreen[\"battle\"] = 1] = \"battle\";\n})(WorldScreen || (WorldScreen = {}));\nclass World {\n    constructor({ app, gameLoader }) {\n        this.resizeTimeout = 300;\n        this.totalWidth = 1024;\n        this.totalHeight = 576;\n        this.resizeDeBounce = () => {\n            this.cancelScheduledResizeHandler();\n            this.scheduleResizeHandler();\n        };\n        this.resizeHandler = () => {\n            const params = { viewWidth: this.app.view.width, viewHeight: this.app.view.height };\n            switch (this.activeScreen) {\n                case WorldScreen.map:\n                    this.mapScreen.handleScreenResize(params);\n                    break;\n                case WorldScreen.battle:\n                    this.battleScreen.handleScreenResize(params);\n                    break;\n            }\n            this.splashScreen.handleScreenResize(params);\n        };\n        this.handleAppTick = () => {\n            switch (this.activeScreen) {\n                case WorldScreen.map:\n                    this.mapScreen.handleScreenTick();\n                    break;\n                case WorldScreen.battle:\n                    this.battleScreen.handleScreenTick();\n                    break;\n            }\n        };\n        this.handleBattleStart = () => {\n            this.setScreen(WorldScreen.battle);\n        };\n        this.app = app;\n        this.gameLoader = gameLoader;\n        this.setup();\n        this.setScreen(WorldScreen.battle, true);\n        this.resizeHandler();\n        if (logger_1.logWorld.enabled) {\n            (0, logger_1.logWorld)('window.world initialized!');\n            window.world = this;\n        }\n    }\n    setup() {\n        this.setupCanvas();\n        this.setupScreens();\n        this.setupEventLesteners();\n    }\n    setupEventLesteners() {\n        window.addEventListener('resize', this.resizeDeBounce);\n        this.app.ticker.add(this.handleAppTick);\n    }\n    findTileLayer(name) {\n        const layer = this.gameLoader.settings.layers.find((l) => l.type === 'tilelayer' && l.name === name);\n        if (layer == null) {\n            throw new Error(`Unable to detect \"${name}\" layer`);\n        }\n        return layer;\n    }\n    setupCanvas() {\n        document.body.appendChild(this.app.view);\n    }\n    setupScreens() {\n        const { app: { view: { width, height } }, gameLoader: { worldBackgroundTexture, worldForegroundTexture, battleBackgroundTexture, spritesheet: { animations } } } = this;\n        this.mapScreen = new MapScreen_1.MapScreen({\n            viewWidth: width,\n            viewHeight: height,\n            collisionsLayer: this.findTileLayer('Collisions'),\n            battleZonesLayer: this.findTileLayer('Battle Zones'),\n            playerSprites: {\n                up: animations['Player-Up'],\n                left: animations['Player-Left'],\n                right: animations['Player-Right'],\n                down: animations['Player-Down']\n            },\n            mapSprites: {\n                background: worldBackgroundTexture,\n                foreground: worldForegroundTexture\n            },\n            onBattleStart: this.handleBattleStart\n        });\n        this.battleScreen = new BattleScreen_1.BattleScreen({\n            viewWidth: width,\n            viewHeight: height,\n            sprites: {\n                draggle: animations['Draggle-Idle'],\n                emby: animations['Emby-Idle'],\n                background: battleBackgroundTexture\n            }\n        });\n        this.splashScreen = new SplashScreen_1.SplashScreen({\n            viewWidth: width,\n            viewHeight: height\n        });\n        this.app.stage.addChild(this.mapScreen);\n        this.app.stage.addChild(this.battleScreen);\n        this.app.stage.addChild(this.splashScreen);\n    }\n    cancelScheduledResizeHandler() {\n        clearTimeout(this.resizeTimeoutId);\n    }\n    scheduleResizeHandler() {\n        this.resizeTimeoutId = setTimeout(() => {\n            this.cancelScheduledResizeHandler();\n            this.resizeHandler();\n        }, this.resizeTimeout);\n    }\n    setScreen(screen, force = false) {\n        switch (screen) {\n            case WorldScreen.map:\n                this.battleScreen.deactivate();\n                if (force) {\n                    this.battleScreen.visible = false;\n                    this.mapScreen.visible = true;\n                    this.mapScreen.activate();\n                }\n                else {\n                    this.splashScreen.alpha = 0;\n                    gsap_1.default.to(this.splashScreen, {\n                        alpha: 1,\n                        onComplete: () => {\n                            this.battleScreen.visible = false;\n                            this.mapScreen.visible = true;\n                            this.mapScreen.activate();\n                            gsap_1.default.to(this.splashScreen, {\n                                alpha: 0,\n                                duration: 0.4\n                            });\n                        }\n                    });\n                }\n                break;\n            case WorldScreen.battle:\n                this.mapScreen.deactivate();\n                if (force) {\n                    this.mapScreen.visible = false;\n                    this.battleScreen.visible = true;\n                    this.battleScreen.activate();\n                }\n                else {\n                    this.splashScreen.alpha = 0;\n                    gsap_1.default.to(this.splashScreen, {\n                        alpha: 1,\n                        repeat: 3,\n                        yoyo: true,\n                        duration: 0.4,\n                        onComplete: () => {\n                            gsap_1.default.to(this.splashScreen, {\n                                alpha: 1,\n                                duration: 0.4,\n                                onComplete: () => {\n                                    this.mapScreen.visible = false;\n                                    this.battleScreen.visible = true;\n                                    this.battleScreen.activate();\n                                    gsap_1.default.to(this.splashScreen, {\n                                        alpha: 0,\n                                        duration: 0.4\n                                    });\n                                }\n                            });\n                        }\n                    });\n                }\n                break;\n        }\n        this.activeScreen = screen;\n        this.resizeHandler();\n    }\n}\nexports.World = World;\nWorld.SCREENS = WorldScreen;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst pixi_js_1 = require(\"pixi.js\");\nrequire(\"./styles.css\");\nconst World_1 = require(\"./World\");\nconst GameLoader_1 = require(\"./GameLoader\");\nasync function run() {\n    const gameLoader = new GameLoader_1.GameLoader();\n    await gameLoader.loadAll();\n    const app = new pixi_js_1.Application({\n        width: window.innerWidth,\n        height: window.innerHeight,\n        backgroundColor: 0xe6e7ea,\n        resizeTo: window\n    });\n    void new World_1.World({ app, gameLoader });\n}\nrun().catch(console.error);\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.logPointerEvent = exports.logMoveInterface = exports.logBoundary = exports.logRectCollision = exports.logPlayerCollision = exports.logPlayerImpulse = exports.logKeyup = exports.logKeydown = exports.logBattleLayout = exports.logWorld = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nexports.logWorld = (0, debug_1.default)('poke-world');\nexports.logBattleLayout = (0, debug_1.default)('poke-battle-layout');\nexports.logKeydown = (0, debug_1.default)('poke-keydown');\nexports.logKeyup = (0, debug_1.default)('poke-keyup');\nexports.logPlayerImpulse = (0, debug_1.default)('poke-player-impulse');\nexports.logPlayerCollision = (0, debug_1.default)('poke-player-collision');\nexports.logRectCollision = (0, debug_1.default)('poke-rect-collision');\nexports.logBoundary = (0, debug_1.default)('poke-boundary');\nexports.logMoveInterface = (0, debug_1.default)('poke-move-interface');\nexports.logPointerEvent = (0, debug_1.default)('poke-pointer-event');\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rectangularCollision = void 0;\nconst logger_1 = require(\"./logger\");\nfunction rectangularCollision({ rect1, rect2 }) {\n    (0, logger_1.logRectCollision)(`r1x=${rect1.x} r1y=${rect1.y} r1w=${rect1.width} r1h=${rect1.height} <> r2x=${rect2.x} r2y=${rect2.y} r2w=${rect2.width} r2h=${rect2.height}`);\n    return (rect1.x + rect1.width >= rect2.x &&\n        rect1.x <= rect2.x + rect2.width &&\n        rect1.y <= rect2.y + rect2.height &&\n        rect1.y + rect1.height >= rect2.y);\n}\nexports.rectangularCollision = rectangularCollision;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"main\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunksimple_html5_pokemon_game\"] = self[\"webpackChunksimple_html5_pokemon_game\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendor\"], () => (__webpack_require__(\"./src/app.ts\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}