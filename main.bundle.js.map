{"version":3,"file":"main.bundle.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC1LA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AEhDA;AACA;AACA;AACA;AACA","sources":["webpack://simple-html5-pokemon-game/./src/BattleScreen.ts","webpack://simple-html5-pokemon-game/./src/Boundary.ts","webpack://simple-html5-pokemon-game/./src/GameLoader.ts","webpack://simple-html5-pokemon-game/./src/MapScreen.ts","webpack://simple-html5-pokemon-game/./src/Player.ts","webpack://simple-html5-pokemon-game/./src/World.ts","webpack://simple-html5-pokemon-game/./src/app.ts","webpack://simple-html5-pokemon-game/./src/logger.ts","webpack://simple-html5-pokemon-game/./src/utils.ts","webpack://simple-html5-pokemon-game/webpack/bootstrap","webpack://simple-html5-pokemon-game/webpack/runtime/chunk loaded","webpack://simple-html5-pokemon-game/webpack/runtime/global","webpack://simple-html5-pokemon-game/webpack/runtime/hasOwnProperty shorthand","webpack://simple-html5-pokemon-game/webpack/runtime/node module decorator","webpack://simple-html5-pokemon-game/webpack/runtime/jsonp chunk loading","webpack://simple-html5-pokemon-game/webpack/before-startup","webpack://simple-html5-pokemon-game/webpack/startup","webpack://simple-html5-pokemon-game/webpack/after-startup"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BattleScreen = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nclass BattleScreen extends pixi_js_1.Container {\n    constructor(options) {\n        super();\n        this.isActive = false;\n        this.animationSpeed = 0.05;\n        this.setup(options);\n    }\n    setup(options) {\n        this.setupBackground(options);\n        this.setupVersus(options);\n    }\n    setupBackground({ sprites: { background } }) {\n        const bgSpr = new pixi_js_1.Sprite(background);\n        this.addChild(bgSpr);\n        this.background = bgSpr;\n    }\n    setupVersus({ sprites: { draggle, emby } }) {\n        const drlSpr = new pixi_js_1.AnimatedSprite(draggle);\n        drlSpr.animationSpeed = this.animationSpeed;\n        drlSpr.play();\n        this.addChild(drlSpr);\n        this.draggle = drlSpr;\n        const embSpr = new pixi_js_1.AnimatedSprite(emby);\n        embSpr.animationSpeed = this.animationSpeed;\n        embSpr.play();\n        this.addChild(embSpr);\n        this.emby = embSpr;\n    }\n    activate() {\n        this.isActive = true;\n    }\n    deactivate() {\n        this.isActive = false;\n    }\n    handleScreenTick() {\n        if (!this.isActive) {\n        }\n    }\n}\nexports.BattleScreen = BattleScreen;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Boundary = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nconst logger_1 = require(\"./logger\");\nclass Boundary extends pixi_js_1.Graphics {\n    constructor({ rect, fillColor = 0xff0000 }) {\n        super();\n        this._rect = rect;\n        this.x = rect.x;\n        this.y = rect.y;\n        this.fillColor = fillColor;\n        this.draw();\n        if (logger_1.logBoundary.enabled) {\n            this.visible = true;\n            this.alpha = 0.3;\n        }\n        else {\n            this.visible = false;\n        }\n    }\n    draw() {\n        this.clear();\n        this.beginFill(this.fillColor);\n        this.drawRect(0, 0, this._rect.width, this._rect.height);\n        this.endFill();\n    }\n}\nexports.Boundary = Boundary;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GameLoader = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nclass GameLoader {\n    constructor() {\n        this.loader = pixi_js_1.Assets;\n    }\n    async loadAll() {\n        await this.loadSettings();\n        await this.loadResources();\n        await this.loadImages();\n    }\n    async loadSettings() {\n        this.settings = await fetch('settings.json').then(async (res) => await res.json());\n    }\n    async loadResources() {\n        this.loader.add('tileset', 'assets/spritesheets/spritesheet.json');\n        this.spritesheet = await this.loader.load('tileset');\n    }\n    async loadImage(url) {\n        const res = await fetch(url);\n        const imageBlob = await res.blob();\n        const blobURL = URL.createObjectURL(imageBlob);\n        return await pixi_js_1.Texture.fromURL(blobURL);\n    }\n    async loadImages() {\n        const [worldBgTexture, worldFgTexture, battleBgTexture] = await Promise.all([\n            this.loadImage('assets/images/World-Background.png'),\n            this.loadImage('assets/images/World-Foreground.png'),\n            this.loadImage('assets/images/Battle-Background.png')\n        ]);\n        this.worldBackgroundTexture = worldBgTexture;\n        this.worldForegroundTexture = worldFgTexture;\n        this.battleBackgroundTexture = battleBgTexture;\n    }\n}\nexports.GameLoader = GameLoader;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MapScreen = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nconst Boundary_1 = require(\"./Boundary\");\nconst logger_1 = require(\"./logger\");\nconst Player_1 = require(\"./Player\");\nconst utils_1 = require(\"./utils\");\nclass MapScreen extends pixi_js_1.Container {\n    constructor(options) {\n        super();\n        this.cellWidth = 48;\n        this.cellHeight = 48;\n        this.isActive = false;\n        this.tilesPerRow = 70;\n        this.boundaries = [];\n        this.battleZones = [];\n        this.handleKeydown = (e) => {\n            const { player } = this;\n            (0, logger_1.logKeydown)(e.key);\n            switch (e.key) {\n                case 'w':\n                case 'ArrowUp':\n                    player.addUpImpulse();\n                    break;\n                case 'a':\n                case 'ArrowLeft':\n                    player.addLeftImpulse();\n                    break;\n                case 's':\n                case 'ArrowDown':\n                    player.addDownImpulse();\n                    break;\n                case 'd':\n                case 'ArrowRight':\n                    player.addRightImpulse();\n                    break;\n            }\n        };\n        this.handleKeyup = (e) => {\n            const { player } = this;\n            (0, logger_1.logKeyup)(e.key);\n            switch (e.key) {\n                case 'w':\n                case 'ArrowUp':\n                    player.subUpImpulse();\n                    break;\n                case 'a':\n                case 'ArrowLeft':\n                    player.subLeftImpulse();\n                    break;\n                case 's':\n                case 'ArrowDown':\n                    player.subDownImpulse();\n                    break;\n                case 'd':\n                case 'ArrowRight':\n                    player.subRightImpulse();\n                    break;\n            }\n        };\n        this.setup(options);\n    }\n    setup(options) {\n        this.setupBackground(options);\n        this.setupLayers(options);\n        this.setupPlayer(options);\n        this.setupForeground(options);\n        this.centerCamera(options);\n    }\n    setupLayers({ collisionsLayer, battleZonesLayer }) {\n        const { tilesPerRow } = this;\n        for (let i = 0; i < collisionsLayer.data.length; i += tilesPerRow) {\n            const row = collisionsLayer.data.slice(i, tilesPerRow + i);\n            row.forEach((symbol, j) => {\n                if (symbol === 1025) {\n                    const boundary = new Boundary_1.Boundary({\n                        rect: {\n                            x: j * this.cellWidth,\n                            y: i / tilesPerRow * this.cellHeight,\n                            width: this.cellWidth,\n                            height: this.cellHeight\n                        }\n                    });\n                    this.boundaries.push(boundary);\n                    this.addChild(boundary);\n                }\n            });\n        }\n        for (let i = 0; i < battleZonesLayer.data.length; i += tilesPerRow) {\n            const row = battleZonesLayer.data.slice(i, tilesPerRow + i);\n            row.forEach((symbol, j) => {\n                if (symbol === 1025) {\n                    const boundary = new Boundary_1.Boundary({\n                        rect: {\n                            x: j * this.cellWidth,\n                            y: i / tilesPerRow * this.cellHeight,\n                            width: this.cellWidth,\n                            height: this.cellHeight\n                        },\n                        fillColor: 0x0000ff\n                    });\n                    this.battleZones.push(boundary);\n                    this.addChild(boundary);\n                }\n            });\n        }\n    }\n    setupBackground({ mapSprites: { background } }) {\n        const bgSpr = new pixi_js_1.Sprite(background);\n        this.addChild(bgSpr);\n        this.background = bgSpr;\n    }\n    setupPlayer({ playerSprites: { up, left, right, down } }) {\n        this.player = new Player_1.Player({\n            position: {\n                x: 1225,\n                y: 880\n            },\n            sprites: {\n                up,\n                left,\n                right,\n                down\n            }\n        });\n        this.addChild(this.player);\n        window.player = this.player; // TODO\n    }\n    setupForeground({ mapSprites: { foreground } }) {\n        const fgSpr = new pixi_js_1.Sprite(foreground);\n        this.addChild(fgSpr);\n        this.foreground = fgSpr;\n    }\n    activate() {\n        this.isActive = true;\n        this.addEventLesteners();\n    }\n    deactivate() {\n        this.isActive = false;\n        this.removeEventLesteners();\n    }\n    handleScreenTick() {\n        if (!this.isActive) {\n            return;\n        }\n        if (this.player.isMoving) {\n            // console.log(this.background.x, this.background.y)\n            const pRect = {\n                x: this.player.x + this.player.getLeftRightImpulse(),\n                y: this.player.y + this.player.getUpDownImpulse(),\n                width: this.player.width,\n                height: this.player.height\n            };\n            for (let i = 0; i < this.boundaries.length; i++) {\n                const boundary = this.boundaries[i];\n                if ((0, utils_1.rectangularCollision)({\n                    rect1: pRect,\n                    rect2: boundary\n                })) {\n                    (0, logger_1.logPlayerCollision)('Collision detected! Player stopped');\n                    this.player.isMoving = false;\n                    break;\n                }\n            }\n        }\n        if (this.player.isMoving) {\n            this.player.x += this.player.getLeftRightImpulse();\n            this.player.y += this.player.getUpDownImpulse();\n            this.x -= this.player.getLeftRightImpulse();\n            this.y -= this.player.getUpDownImpulse();\n        }\n    }\n    addEventLesteners() {\n        window.addEventListener('keydown', this.handleKeydown);\n        window.addEventListener('keyup', this.handleKeyup);\n    }\n    removeEventLesteners() {\n        window.removeEventListener('keydown', this.handleKeydown);\n        window.removeEventListener('keyup', this.handleKeyup);\n    }\n    centerCamera({ viewWidth, viewHeight }) {\n        this.x = -this.player.x + viewWidth / 2;\n        this.y = -this.player.y + viewHeight / 2;\n    }\n}\nexports.MapScreen = MapScreen;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Player = void 0;\nconst pixi_js_1 = require(\"pixi.js\");\nconst logger_1 = require(\"./logger\");\nvar PlayerDirection;\n(function (PlayerDirection) {\n    PlayerDirection[PlayerDirection[\"up\"] = 0] = \"up\";\n    PlayerDirection[PlayerDirection[\"down\"] = 1] = \"down\";\n    PlayerDirection[PlayerDirection[\"left\"] = 2] = \"left\";\n    PlayerDirection[PlayerDirection[\"right\"] = 3] = \"right\";\n})(PlayerDirection || (PlayerDirection = {}));\nclass Player extends pixi_js_1.Container {\n    constructor(options) {\n        super();\n        this.DIRECTIONS = PlayerDirection;\n        this.animationSpeed = 0.1;\n        this.velocity = 3;\n        this.isMoving = false;\n        this.impulse = {\n            up: false,\n            left: false,\n            right: false,\n            down: false\n        };\n        this.setup(options);\n        this.setDirection(PlayerDirection.down);\n        this.x = options.position.x;\n        this.y = options.position.y;\n    }\n    hideAllDirections() {\n        [this.up, this.left, this.right, this.down].forEach(spr => {\n            spr.visible = false;\n        });\n    }\n    setDirection(dir) {\n        this.hideAllDirections();\n        switch (dir) {\n            case PlayerDirection.down:\n                this.down.visible = true;\n                break;\n            case PlayerDirection.left:\n                this.left.visible = true;\n                break;\n            case PlayerDirection.right:\n                this.right.visible = true;\n                break;\n            case PlayerDirection.up:\n                this.up.visible = true;\n                break;\n        }\n        this._direction = dir;\n    }\n    stopAllAnimations() {\n        [this.up, this.left, this.right, this.down].forEach(spr => {\n            spr.stop();\n        });\n    }\n    playAnimation() {\n        this.stopAllAnimations();\n        switch (this._direction) {\n            case PlayerDirection.down:\n                this.down.play();\n                break;\n            case PlayerDirection.left:\n                this.left.play();\n                break;\n            case PlayerDirection.right:\n                this.right.play();\n                break;\n            case PlayerDirection.up:\n                this.up.play();\n                break;\n        }\n    }\n    setup({ sprites: { up, left, right, down } }) {\n        const upSpr = new pixi_js_1.AnimatedSprite(up);\n        upSpr.animationSpeed = this.animationSpeed;\n        this.addChild(upSpr);\n        this.up = upSpr;\n        const leftSpr = new pixi_js_1.AnimatedSprite(left);\n        leftSpr.animationSpeed = this.animationSpeed;\n        this.addChild(leftSpr);\n        this.left = leftSpr;\n        const righSpr = new pixi_js_1.AnimatedSprite(right);\n        righSpr.animationSpeed = this.animationSpeed;\n        this.addChild(righSpr);\n        this.right = righSpr;\n        const downSpr = new pixi_js_1.AnimatedSprite(down);\n        downSpr.animationSpeed = this.animationSpeed;\n        this.addChild(downSpr);\n        this.down = downSpr;\n    }\n    setImpulse(impulse) {\n        /* eslint-disable @typescript-eslint/restrict-template-expressions */\n        (0, logger_1.logPlayerImpulse)(`Got impulse up=${impulse.up} left=${impulse.left} right=${impulse.right} down=${impulse.down}`);\n        Object.assign(this.impulse, impulse);\n        if (impulse.up === true) {\n            this.setDirection(PlayerDirection.up);\n            if (this.impulse.down) {\n                this.impulse.down = false;\n            }\n        }\n        else if (impulse.left === true) {\n            this.setDirection(PlayerDirection.left);\n            if (this.impulse.right) {\n                this.impulse.right = false;\n            }\n        }\n        else if (impulse.right === true) {\n            this.setDirection(PlayerDirection.right);\n            if (this.impulse.left) {\n                this.impulse.left = false;\n            }\n        }\n        else if (impulse.down === true) {\n            this.setDirection(PlayerDirection.down);\n            if (this.impulse.up) {\n                this.impulse.up = false;\n            }\n        }\n        if (this.impulse.up || this.impulse.left || this.impulse.right || this.impulse.down) {\n            this.isMoving = true;\n            this.playAnimation();\n        }\n        else {\n            this.stopAllAnimations();\n            this.isMoving = false;\n        }\n        (0, logger_1.logPlayerImpulse)(`(Moving=${this.isMoving} up=${this.impulse.up} left=${this.impulse.left} right=${this.impulse.right} down=${this.impulse.down}`);\n        /* eslint-enable @typescript-eslint/restrict-template-expressions */\n    }\n    addUpImpulse() {\n        this.setImpulse({ up: true });\n    }\n    subUpImpulse() {\n        this.setImpulse({ up: false });\n    }\n    addLeftImpulse() {\n        this.setImpulse({ left: true });\n    }\n    subLeftImpulse() {\n        this.setImpulse({ left: false });\n    }\n    addRightImpulse() {\n        this.setImpulse({ right: true });\n    }\n    subRightImpulse() {\n        this.setImpulse({ right: false });\n    }\n    addDownImpulse() {\n        this.setImpulse({ down: true });\n    }\n    subDownImpulse() {\n        this.setImpulse({ down: false });\n    }\n    releaseAllImpulse() {\n        this.setImpulse({ up: false, left: false, right: false, down: false });\n    }\n    getUpDownImpulse() {\n        return this.impulse.up ? -this.velocity : this.impulse.down ? this.velocity : 0;\n    }\n    getLeftRightImpulse() {\n        return this.impulse.left ? -this.velocity : this.impulse.right ? this.velocity : 0;\n    }\n}\nexports.Player = Player;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.World = void 0;\nconst logger_1 = require(\"./logger\");\nconst MapScreen_1 = require(\"./MapScreen\");\nconst BattleScreen_1 = require(\"./BattleScreen\");\nvar WorldScreen;\n(function (WorldScreen) {\n    WorldScreen[WorldScreen[\"map\"] = 0] = \"map\";\n    WorldScreen[WorldScreen[\"battle\"] = 1] = \"battle\";\n})(WorldScreen || (WorldScreen = {}));\nclass World {\n    constructor({ app, gameLoader }) {\n        this.resizeTimeout = 300;\n        this.totalWidth = 1024;\n        this.totalHeight = 576;\n        this.resizeDeBounce = () => {\n            this.cancelScheduledResizeHandler();\n            this.scheduleResizeHandler();\n        };\n        this.resizeHandler = () => {\n            const { app, totalWidth, totalHeight } = this;\n            const availableWidth = app.view.width;\n            const availableHeight = app.view.height;\n            let scale = 1;\n            if (totalHeight >= totalWidth) {\n                scale = availableHeight / totalHeight;\n                if (scale * totalWidth > availableWidth) {\n                    scale = availableWidth / totalWidth;\n                }\n                (0, logger_1.logPokeLayout)(`By height (sc=${scale})`);\n            }\n            else {\n                scale = availableWidth / totalWidth;\n                (0, logger_1.logPokeLayout)(`By width (sc=${scale})`);\n                if (scale * totalHeight > availableHeight) {\n                    scale = availableHeight / totalHeight;\n                }\n            }\n            const occupiedWidth = Math.floor(totalWidth * scale);\n            const occupiedHeight = Math.floor(totalHeight * scale);\n            const x = availableWidth > occupiedWidth ? (availableWidth - occupiedWidth) / 2 : 0;\n            const y = availableHeight > occupiedHeight ? (availableHeight - occupiedHeight) / 2 : 0;\n            (0, logger_1.logPokeLayout)(`aw=${availableWidth} (ow=${occupiedWidth}) x=${x} ah=${availableHeight} (oh=${occupiedHeight}) y=${y}`);\n            this.app.stage.x = x;\n            this.app.stage.width = occupiedWidth;\n            this.app.stage.y = y;\n            this.app.stage.height = occupiedHeight;\n            (0, logger_1.logPokeLayout)(`x=${x} y=${y} stgw=${this.app.stage.width} stgh=${this.app.stage.height}`);\n        };\n        this.handleAppTick = () => {\n            switch (this.screen) {\n                case WorldScreen.map:\n                    this.mapScreen.handleScreenTick();\n                    break;\n                case WorldScreen.battle:\n                    this.battleScreen.handleScreenTick();\n                    break;\n            }\n        };\n        this.app = app;\n        this.gameLoader = gameLoader;\n        this.setup();\n        this.setScreen(WorldScreen.map);\n        window.app = this.app; // TODO\n    }\n    setup() {\n        this.setupCanvas();\n        this.setupScreens();\n        this.setupEventLesteners();\n        // this.resizeHandler()\n    }\n    setupEventLesteners() {\n        // window.addEventListener('resize', this.resizeDeBounce)\n        this.app.ticker.add(this.handleAppTick);\n    }\n    findTileLayer(name) {\n        const layer = this.gameLoader.settings.layers.find((l) => l.type === 'tilelayer' && l.name === name);\n        if (layer == null) {\n            throw new Error(`Unable to detect \"${name}\" layer`);\n        }\n        return layer;\n    }\n    setupCanvas() {\n        document.body.appendChild(this.app.view);\n    }\n    setupScreens() {\n        const { app: { view: { width, height } }, gameLoader: { worldBackgroundTexture, worldForegroundTexture, battleBackgroundTexture, spritesheet: { animations } } } = this;\n        this.mapScreen = new MapScreen_1.MapScreen({\n            viewWidth: width,\n            viewHeight: height,\n            collisionsLayer: this.findTileLayer('Collisions'),\n            battleZonesLayer: this.findTileLayer('Battle Zones'),\n            playerSprites: {\n                up: animations['Player-Up'],\n                left: animations['Player-Left'],\n                right: animations['Player-Right'],\n                down: animations['Player-Down']\n            },\n            mapSprites: {\n                background: worldBackgroundTexture,\n                foreground: worldForegroundTexture\n            }\n        });\n        this.battleScreen = new BattleScreen_1.BattleScreen({\n            sprites: {\n                draggle: animations['Draggle-Idle'],\n                emby: animations['Emby-Idle'],\n                background: battleBackgroundTexture\n            }\n        });\n        this.app.stage.addChild(this.mapScreen);\n        this.app.stage.addChild(this.battleScreen);\n    }\n    cancelScheduledResizeHandler() {\n        clearTimeout(this.resizeTimeoutId);\n    }\n    scheduleResizeHandler() {\n        this.resizeTimeoutId = setTimeout(() => {\n            this.cancelScheduledResizeHandler();\n            this.resizeHandler();\n        }, this.resizeTimeout);\n    }\n    setScreen(screen) {\n        switch (screen) {\n            case WorldScreen.map:\n                this.mapScreen.visible = true;\n                this.mapScreen.activate();\n                this.battleScreen.visible = false;\n                this.battleScreen.deactivate();\n                break;\n            case WorldScreen.battle:\n                this.mapScreen.visible = false;\n                this.mapScreen.deactivate();\n                this.battleScreen.visible = true;\n                this.battleScreen.activate();\n                break;\n        }\n        this.screen = screen;\n    }\n}\nexports.World = World;\nWorld.SCREENS = WorldScreen;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst pixi_js_1 = require(\"pixi.js\");\nconst World_1 = require(\"./World\");\nconst GameLoader_1 = require(\"./GameLoader\");\nasync function run() {\n    const gameLoader = new GameLoader_1.GameLoader();\n    await gameLoader.loadAll();\n    const app = new pixi_js_1.Application({\n        width: window.innerWidth,\n        height: window.innerHeight,\n        backgroundColor: 0xe6e7ea,\n        resizeTo: window\n    });\n    void new World_1.World({ app, gameLoader });\n}\nrun().catch(console.error);\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.logBoundary = exports.logPlayerCollision = exports.logPlayerImpulse = exports.logKeyup = exports.logKeydown = exports.logPokeLayout = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nexports.logPokeLayout = (0, debug_1.default)('poke-layout');\nexports.logKeydown = (0, debug_1.default)('poke-keydown');\nexports.logKeyup = (0, debug_1.default)('poke-keyup');\nexports.logPlayerImpulse = (0, debug_1.default)('poke-player-impulse');\nexports.logPlayerCollision = (0, debug_1.default)('poke-player-collision');\nexports.logBoundary = (0, debug_1.default)('poke-boundary');\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.rectangularCollision = void 0;\nconst logger_1 = require(\"./logger\");\nfunction rectangularCollision({ rect1, rect2 }) {\n    (0, logger_1.logPlayerCollision)(`r1x=${rect1.x} r1y=${rect1.y} r1w=${rect1.width} r1h=${rect1.height} <> r2x=${rect2.x} r2y=${rect2.y} r2w=${rect2.width} r2h=${rect2.height}`);\n    return (rect1.x + rect1.width >= rect2.x &&\n        rect1.x <= rect2.x + rect2.width &&\n        rect1.y <= rect2.y + rect2.height &&\n        rect1.y + rect1.height >= rect2.y);\n}\nexports.rectangularCollision = rectangularCollision;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\tid: moduleId,\n\t\tloaded: false,\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Flag the module as loaded\n\tmodule.loaded = true;\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.nmd = (module) => {\n\tmodule.paths = [];\n\tif (!module.children) module.children = [];\n\treturn module;\n};","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"main\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunksimple_html5_pokemon_game\"] = self[\"webpackChunksimple_html5_pokemon_game\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"vendor\"], () => (__webpack_require__(\"./src/app.ts\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}